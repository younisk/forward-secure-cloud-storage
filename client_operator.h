// Copyright 2023 Younis Khalil
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
// documentation files (the "Software"), to deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the
// Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
//

#ifndef SECURECLOUDSTORAGE_CLIENT_OPERATOR_H
#define SECURECLOUDSTORAGE_CLIENT_OPERATOR_H


#include <pkw/pkw/pkw.h>
#include <filesystem>
#include <map>
#include <utility>
#include <future>
#include "cloud_communicator.h"
#include "id_provider.h"

#include <cstddef>
#include "client_operator.h"
#include <cryptopp/rdrand.h>
#include <pkw/secure_byte_buffer.h>
#include <pkw/pkw/helpers/password_encrypt.h>
#include <fstream>
#include <execution>
#include <algorithm>
#include <utility>
#include <pkw/pkw/exceptions.h>

#define MAX_RETRIES 10

namespace secure_cloud_storage {

    typedef std::vector<unsigned char> ciphertext;

    /**
     * A class which handles client operations, and communicates with the cloud system.
     * T is the type of the file identifier.
     */
    template<class T>
    class ClientOperator {
        protected:
            std::shared_ptr<AbstractPKW<T, ciphertext>> pkw;
            int key_len;
            int tag_len;

            std::shared_ptr<CloudCommunicator<T>> comm;

            std::shared_ptr<IdProvider<T>> id_provider;


        public:
            /**
             * Construct an object from an existing PKW object and lookup table.
             * @param pkw The PKW, reconstructed from a previously exported key.
             * @param id_provider the lookup table, linking local file names with the random identifiers of the cloud.
             * @param tag_len the length of tags.
             * @param key_len the length of keys.
             */
            ClientOperator(std::shared_ptr<AbstractPKW<T, ciphertext>> pkw,
                           std::shared_ptr<IdProvider<T>> id_provider, int tag_len, int key_len,
                           std::shared_ptr<CloudCommunicator<T>> cloud_comm);

            /**
             * Construct an object with fresh secrets.
             * @param tag_len the length of tags.
             * @param key_len the length of keys.
             */
            ClientOperator(int tag_len, int key_len, std::shared_ptr<CloudCommunicator<T>> comm,
                           const std::shared_ptr<IdProvider<T>> &id_provider,
                           const std::shared_ptr<AbstractPKW<T, ciphertext>> pkw) : key_len(key_len),
                                                                                    tag_len(tag_len),
                                                                                    comm(std::move(comm)),
                                                                                    id_provider(id_provider),
                                                                                    pkw(pkw) {};
            /**
             * Return the used key length.
             * @return key length.
             */
            [[nodiscard]] int get_key_len() const { return key_len; };

            /**
             * Return the used tag length.
             * @return tag length.
             */
            [[nodiscard]] int get_tag_len() const { return tag_len; };

            /**
             * Uploads the file under a pseudonym id. Stores the file name locally.
             * @param file_name the local path to the file.
             * @param file_content the contents of the file.
             * @param bucket_name the name of the google cloud bucket.
             * @return the id.
             */
            Id<T> put(const std::filesystem::path &file_name, std::vector<unsigned char> &file_content);

            /**
             * Get the file stored under the pseudonym id.
             * @param id the id, generated by the operation `put`.
             * @param bucket_name the name of the google cloud bucket.
             * @return the contents of the file
             */
            std::vector<unsigned char> get(const Id<T> &id);

            /**
             * Irrevocably delete the file stored under the pseudonym *id*.
             * @param id the pseudonym id of the file.
             */
            void shred(const Id<T> &id);

            /**
             * Rotate the keys used to encrypt individual files. Used to improve performance after repeated `shred` operations.
             * @param the new pkw object to use
             * @return the number of files affected by the operation.
             */
            size_t rotate_keys(std::shared_ptr<AbstractPKW<T, ciphertext>> new_pkw);

            /**
             * Lookup the local name of the file stored under id.
             * @param id.
             * @return the name.
             */
            std::string get_file_name(Id<T> id);

            /**
             * Lookup the id for corresponding the the local file name.
             * @param file_name the file name.
             * @return the id.
             */
            Id<T> get_id(const std::string &file_name);


            /**
             * List the files stored by the system.
             * @return the list of file names.
             */
            std::vector<std::string> list_files();

            /**
             * Removes files from the cloud storage which do not have a corresponding entry in the lookup table.
             * @param bucket_name the name of the google cloud bucket.
             * @return the number of deleted items.
             */
            size_t clean();

            /**
             * Export the secret key used the the PKW scheme.
             * @return the key.
             */
            SecureByteBuffer export_key();

            std::vector<unsigned char> eps = {0};
            const int nonce_len = 16;
    };
    // private functions, not part of API

// public functions, part of API

    template<class T>
    Id<T> ClientOperator<T>::put(const std::filesystem::path &file_name, std::vector<unsigned char> &file_content) {
        Id<T> id = id_provider->get_id(file_name);

        std::vector<unsigned char> dek(
                key_len / 8); // pkw library doesn't support SecureByteBuffer as key-to-be-wrapped, add?

        CryptoPP::RDRAND prng;
        // generate a data encryption key
        prng.GenerateBlock(dek.data(), dek.size());
        // Wrap the data encryption key using the random tag, with the constant eps as additional data (header)
        bool wrapping_failed = false;
        int wrap_tries = 0;
        std::vector<unsigned char> wrapped_key;
        do {
            // the random tag could have been punctured before, so
            try {
                wrapped_key = pkw->wrap(id.getLocalId(), eps, dek);
                wrap_tries++;
            } catch (std::exception &e) {
                if (wrap_tries > MAX_RETRIES) {
                    throw std::runtime_error("Could not wrap after " + std::to_string(MAX_RETRIES) +
                                             " attempts, you may want to rotate keys.");
                }
                id = id_provider->get_id(file_name);
                wrapping_failed = true;
            }
        } while (wrapping_failed);

        // Encrypt file
        std::vector<unsigned char> file_content_copy(file_content);
        SecureByteBuffer plaintext(file_content_copy);
        SecureByteBuffer data_key(dek);
        SecureByteBuffer nonce(nonce_len);
        prng.GenerateBlock(nonce.data(), nonce.size());
        const std::vector<unsigned char> encrypted_file = encrypt(plaintext, data_key, nonce, eps);

        // push to cloud
        comm->write_to_cloud(id, wrapped_key, encrypted_file, nonce);

        return id;
    }

    template<class T>
    std::vector<unsigned char> ClientOperator<T>::get(const Id<T> &id) {
        // check file exists
        if (!id_provider->exists_id(id)) {
            throw std::runtime_error("File does not exist");
        }
        std::string nonce_and_file = comm->read_from_cloud(comm->id_to_cloud_name(id));
        std::string header = comm->read_from_cloud(comm->id_to_cloud_header(id));
        std::vector<unsigned char> header_buffer = std::vector<unsigned char>{header.begin(), header.end()};
        auto dek = pkw->unwrap(id.getLocalId(), eps, header_buffer);
        auto nonce = std::vector<unsigned char>(nonce_and_file.begin(), nonce_and_file.begin() + nonce_len);
        auto ctxt = std::vector<unsigned char>(nonce_and_file.begin() + nonce_len, nonce_and_file.end());

        auto dek_buff = SecureByteBuffer(dek);
        auto nonce_buff = SecureByteBuffer(nonce);
        auto ctxt_buff = SecureByteBuffer(ctxt);

        auto file = decrypt(ctxt_buff, dek_buff, nonce_buff, eps);
        return {file.begin(), file.end()};
    }

    template<class T>
    std::string ClientOperator<T>::get_file_name(Id<T> id) {
        if (!id_provider->exists_id(id)) {
            throw std::runtime_error("File not found.");
        }
        return id_provider->get_file_path(id);
    }

    template<class T>
    Id<T> ClientOperator<T>::get_id(const std::string &file_name) {
        if (!id_provider->exists_file(file_name)) {
            throw std::runtime_error("File not found.");
        }
        return id_provider->get_id(file_name);
    }

    template<class T>
    void ClientOperator<T>::shred(const Id<T> &id) {
        // check whether id is known
        if (!id_provider->exists_id(id)) {
            return;
        }

        // delete from lookup table
        pkw->punc(id.getLocalId());

        id_provider->remove(id);

        // delete file from cloud storage
        comm->enqueue_delete(id);
    }


    template<class T>
    std::vector<std::string> ClientOperator<T>::list_files() {
        std::vector<std::string> files;
        for (auto &id: id_provider->list_ids()) {
            files.emplace_back(id_provider->get_file_path(id));
        }
        return files;
    }

    template<class T>
    size_t ClientOperator<T>::clean() {
        return comm->clean_storage(id_provider->list_ids());
    }


    template<class T>
    ClientOperator<T>::ClientOperator(std::shared_ptr<AbstractPKW<T, ciphertext>> pkw,
                                      std::shared_ptr<IdProvider<T>> id_provider, int tag_len, int key_len,
                                      std::shared_ptr<CloudCommunicator<T>> cloud_comm)
            : pkw(std::move(pkw)), id_provider(std::move(id_provider)), tag_len(tag_len), key_len(key_len),
              comm(std::move(cloud_comm)) {}

    template<class T>
    SecureByteBuffer ClientOperator<T>::export_key() {
        return pkw->serializeKey();
    }

    template<class T>
    size_t ClientOperator<T>::rotate_keys(std::shared_ptr<AbstractPKW<T, ciphertext>> new_pkw) {
        // iterate over all headers (wrapped keys) and re-wrap them
        std::vector<std::future<void>> results;
        std::vector<Id<T>> orphaned_objects;
        for (Id<T> &id: id_provider->list_ids()) {
            results.emplace_back(
                    std::async(std::launch::async,
                               [new_pkw, this, id, &orphaned_objects]() -> void {
                                   // get key wrapped under current pkw key
                                   std::string old_head = comm->read_from_cloud(comm->id_to_cloud_header(id));
                                   std::vector<unsigned char> old_wrapped_key{
                                           old_head.begin(),
                                           old_head.end()};

                                   try {
                                       auto unwrapped_key = pkw->unwrap(id.getLocalId(), eps, old_wrapped_key);
                                       // wrap the key under the new pkw key
                                       auto new_wrapped_key = new_pkw->wrap(id.getLocalId(), eps,
                                                                            unwrapped_key);
                                       comm->write_header_to_cloud(id, new_wrapped_key);
                                       return;
                                   } catch (PuncturableKeyWrappingException &e) {
                                       // if a header cannot be decrypted, it was shredded: delete header & file
                                       orphaned_objects.emplace_back(id);
                                   }
                               }
                    )
            );
        }

        // wait for parallel operations to complete
        for (auto &res: results) {
            res.wait();
        }

        for (auto &id: orphaned_objects) {
            comm->enqueue_delete(id);

            //delete entries from lookup tables
            id_provider->remove(id);
        }
        comm->handle_delete_queue();

        // replace old pkw object (with old key)
        pkw = new_pkw;


        return id_provider->size();
    }
}
#endif //SECURECLOUDSTORAGE_CLIENT_OPERATOR_H